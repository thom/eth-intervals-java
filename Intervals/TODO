* Remove `pendingWorkItems' => always put work item into one of the worker's 
  queues instead:
- Assign it randomly, or
- Assign it to the worker with the smallest queue, or
- Execute eagerly

=> Be careful with race conditions!
=> idleLock should prevent us from having a race condition.


=> Do benchmarks, if faster:

* Replace `ArrayList<Worker> idleWorkers' with a concurrent queue
- Non-blocking (`ConcurrentLinkedQueue<Worker>'), or
- Blocking (`LinkedBlockingDeque<Worker>', `ArrayBlockingQueue<Worker>', 
            `LinkedBlockingQueue<Worker>')

* Move `idleLock' into `startKeepAliveThread' and `stopKeepAliveThread'
- Is this really a good idea? What about race conditions?


If benchmarks show, it's slower:

* Replace `ArrayList<Worker> idleWorkers' with a concurrrent queue

* Replace `ArrayList<WorkItem> pendingWorkItems' with a concurrent queue

* Move `idleLock' into `startKeepAliveThread' and `stopKeepAliveThread'


Other idea: Ignore idle workers

* Random assignment of tasks
* Assign tasks to worker with smallest work item queue
